package main

import (
	"sort"
	"strings"
	"unicode"

	"github.com/gogo/protobuf/proto"
	"github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	plugin "github.com/gogo/protobuf/protoc-gen-gogo/plugin"
	"github.com/gogo/protobuf/vanity/command"

	"dropbox/build_tools/codegen"
	proto_codegen "dropbox/build_tools/codegen/proto"
	"dropbox/proto/mypy"
)

const (
	protoContainersPkg     = "google/protobuf/internal/containers"
	forceKeyValueArgsClass = "_MYPY_ForceKeyValueArguments"
	forceKeyValueArgsArg   = "_mypy_force_key_value_arguments"
)

// these are reserved names. If a class has exactly this name, we will prefix the class name
// with _, then create an alias to it, to avoid collision when referencing it
var reservedNames = []string{"Name", "Value"}

// these are keywords. If a field has exactly this name, we will comment it out to avoid
// invalid syntax.
var keywords = map[string]struct{}{
	"False":    {},
	"None":     {},
	"True":     {},
	"and":      {},
	"as":       {},
	"assert":   {},
	"async":    {},
	"await":    {},
	"break":    {},
	"class":    {},
	"continue": {},
	"def":      {},
	"del":      {},
	"elif":     {},
	"else":     {},
	"except":   {},
	"finally":  {},
	"for":      {},
	"from":     {},
	"global":   {},
	"if":       {},
	"import":   {},
	"in":       {},
	"is":       {},
	"lambda":   {},
	"nonlocal": {},
	"not":      {},
	"or":       {},
	"pass":     {},
	"raise":    {},
	"return":   {},
	"try":      {},
	"while":    {},
	"with":     {},
	"yield":    {},
}

// Is c an ASCII upper-case letter?
func isASCIIUpper(c byte) bool {
	return 'A' <= c && c <= 'Z'
}

func isScalar(fd *descriptor.FieldDescriptorProto) bool {
	switch fd.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE,
		descriptor.FieldDescriptorProto_TYPE_GROUP:
		return false
	default:
		return true
	}
}

type pkgWriter struct {
	codegen.LineWriter

	pkgs *codegen.PythonPkgMap

	fd *descriptor.FileDescriptorProto

	descriptors *proto_codegen.Descriptors
}

func newPkgWriter(fd *descriptor.FileDescriptorProto,
	descriptors *proto_codegen.Descriptors) *pkgWriter {
	return &pkgWriter{
		LineWriter:  codegen.NewLineWriter("    "),
		pkgs:        codegen.NewPythonPkgMap(),
		fd:          fd,
		descriptors: descriptors,
	}
}

func (w *pkgWriter) String() string {
	// Trick tails with a little string concat
	hdr := "# @" + "generated by protoc-gen-mypy.  Do not edit!\n# -*- coding: utf-8 -*-\n\n"
	return hdr + w.pkgs.String() + w.LineWriter.String()
}

func (w *pkgWriter) Name(path string, name string) *codegen.ImportName {
	return w.pkgs.From(path, name)
}

func (w *pkgWriter) RegisterLocal(name string) {
	w.pkgs.RegisterLocal(name)
}

func (w *pkgWriter) isReservedName(name string) bool {
	for _, reserved := range reservedNames {
		if name == reserved {
			return true
		}
	}
	return false
}

func (w *pkgWriter) isKeyword(name string) bool {
	_, ok := keywords[name]
	return ok
}

func (w *pkgWriter) WriteHeader() {
	l := w.Line
	push := w.PushIndent
	pop := w.PopIndent

	l("class %s(object):", forceKeyValueArgsClass)
	push()
	l("pass")
	pop()
	l("")
}

func (w *pkgWriter) WritePublicImports(
	fd *descriptor.FileDescriptorProto, fds []*descriptor.FileDescriptorProto) {

	if len(fd.GetPublicDependency()) == 0 {
		return
	}

	fdByName := make(map[string]*descriptor.FileDescriptorProto, len(fds))
	for _, otherFd := range fds {
		fdByName[otherFd.GetName()] = otherFd
	}

	var publicImports []*descriptor.FileDescriptorProto
	seenFileNames := map[string]struct{}{fd.GetName(): struct{}{}}
	queue := []*descriptor.FileDescriptorProto{fd}

	for len(queue) > 0 {
		importFd := queue[len(queue)-1]
		queue = queue[:len(queue)-1]

		for _, publicImportIndex := range importFd.GetPublicDependency() {
			fileName := importFd.GetDependency()[publicImportIndex]
			if _, ok := seenFileNames[fileName]; !ok {
				seenFileNames[fileName] = struct{}{}
				queue = append(queue, fdByName[fileName])
				publicImports = append(publicImports, fdByName[fileName])
			}
		}
	}

	sort.Slice(publicImports, func(i, j int) bool {
		return publicImports[i].GetName() < publicImports[j].GetName()
	})

	addAlias := func(pkg string, name string) {
		w.Line("%s = %s", name, w.Name(pkg, name))
		w.RegisterLocal(name)
	}

	for _, publicImport := range publicImports {
		w.Line("# Public imports from \"%s\".", publicImport.GetName())

		for _, msg := range publicImport.GetMessageType() {
			addAlias(publicImport.GetName(), msg.GetName())
		}

		for _, enum := range publicImport.GetEnumType() {
			addAlias(publicImport.GetName(), enum.GetName())
			for _, option := range enum.Value {
				addAlias(publicImport.GetName(), option.GetName())
			}
		}

		w.Line("")
	}
}

func (w *pkgWriter) WriteEnums(
	enums []*descriptor.EnumDescriptorProto,
	prefix string,
	comments *proto_codegen.Comments,
	locations ...int32,
) {
	l := w.Line
	push := w.PushIndent
	pop := w.PopIndent
	name := w.Name

	text := w.Name("typing", "Text")
	for i, enumType := range enums {
		enumLocation := append(append([]int32{}, locations...), int32(i))
		if location, ok := comments.Get(enumLocation...); ok {
			w.writeComments(location)
		}
		w.RegisterLocal(enumType.GetName())
		// Protobuf enums are instances of EnumWrapperType which is not a proper Python
		// enum. In order to type check properly we create a custom class for each enum with
		// the same interface as EnumWrapperType but extending int.
		qualifiedName := prefix + enumType.GetName()
		l("class %s(%s):", enumType.GetName(),
			codegen.NewNestedImport(w.Name("builtins", ""), "int"))
		push()
		for valIdx, val := range enumType.Value {
			valLocation := append(append([]int32{}, enumLocation...),
				getFieldNumber(enumType, "value"), int32(valIdx))
			if location, ok := comments.Get(valLocation...); ok {
				w.writeComments(location)
			}
			l("%s: %s", val.GetName(), qualifiedName)
		}
		l("@classmethod")
		// intentionally using int for `number` here, as we don't necessarily know if
		// the number is a valid enum
		l("def Name(cls, number: %s) -> str: ...",
			codegen.NewNestedImport(w.Name("builtins", ""), "int"))
		l("@classmethod")
		l("def Value(cls, name: %s) -> %s: ...", text, qualifiedName)
		l("@classmethod")
		l("def keys(cls) -> %s[%s]: ...",
			name("typing", "List"), text)
		l("@classmethod")
		l("def values(cls) -> %s[%s]: ...",
			name("typing", "List"), qualifiedName)
		l("@classmethod")
		l("def items(cls) -> %s[%s[%s, %s]]: ...",
			name("typing", "List"),
			name("typing", "Tuple"),
			text, qualifiedName)
		pop()
		for _, val := range enumType.Value {
			l("%s: %s", val.GetName(), enumType.GetName())
		}
		if i < len(enums)-1 {
			l("")
		}
	}
}

func (w *pkgWriter) writeComment(comment string) {
	comment = strings.TrimRightFunc(comment, unicode.IsSpace)
	for _, line := range strings.Split(comment, "\n") {
		line = strings.TrimRightFunc(line, unicode.IsSpace)
		w.Line("# %s", line)
	}
}

func (w *pkgWriter) writeComments(location *descriptor.SourceCodeInfo_Location) {
	for _, comment := range location.GetLeadingDetachedComments() {
		w.writeComment(comment)
		w.Line("")
	}
	if location.GetLeadingComments() != "" {
		w.writeComment(location.GetLeadingComments())
	}
}

func (w *pkgWriter) WriteMessages(
	messages []*descriptor.DescriptorProto,
	prefix string,
	comments *proto_codegen.Comments,
	locations ...int32,
) {

	l := w.Line
	push := w.PushIndent
	pop := w.PopIndent
	name := w.Name

	messageClass := name("google.protobuf.message", "Message")

	for i, desc := range messages {
		msgLocation := append(append([]int32{}, locations...), int32(i))
		if location, ok := comments.Get(msgLocation...); ok {
			w.writeComments(location)
		}
		clsName := desc.GetName()
		if w.isReservedName(clsName) && prefix == "" {
			clsName = "_" + clsName
		}
		w.RegisterLocal(clsName)
		qualifiedName := prefix + clsName

		l("class %s(%s):", clsName, messageClass)

		push()
		w.WriteEnums(desc.EnumType, qualifiedName+".", comments,
			append(append([]int32{}, msgLocation...), getFieldNumber(desc, "enum_type"))...)
		w.WriteMessages(desc.NestedType, qualifiedName+".", comments,
			append(append([]int32{}, msgLocation...), getFieldNumber(desc, "nested_type"))...)

		for _, field := range desc.Field {
			l(strings.ToUpper(field.GetName())+"_FIELD_NUMBER: %s",
				codegen.NewNestedImport(w.Name("builtins", ""), "int"))
		}

		l("")

		// Write types of each scalar field.
		for fieldIdx, field := range desc.Field {
			if !isScalar(field) {
				continue
			}
			fieldLocation := append(append([]int32{}, msgLocation...),
				getFieldNumber(desc, "field"), int32(fieldIdx))
			if location, ok := comments.Get(fieldLocation...); ok {
				w.writeComments(location)
			}
			maybeComment := ""
			if w.isKeyword(field.GetName()) {
				maybeComment = "# "
			}
			if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
				container := name(protoContainersPkg, "RepeatedScalarFieldContainer")
				l("%s%s: %s[%s]", maybeComment, field.GetName(), container, w.pythonType(field))
			} else {
				l("%s%s: %s", maybeComment, field.GetName(), w.pythonType(field))
			}
		}

		l("")

		// Write getters for non-scalar fields. Note that we omit setters to prevent
		// people from doing proto.foo = FooProto instead of proto.foo.SetFrom(FooProto)

		var hasSelfField = false
		for fieldIdx, field := range desc.Field {
			if field.GetName() == "self" {
				hasSelfField = true
			}
			if isScalar(field) {
				continue
			}
			fieldLocation := append(append([]int32{}, msgLocation...),
				getFieldNumber(desc, "field"), int32(fieldIdx))
			if location, ok := comments.Get(fieldLocation...); ok {
				w.writeComments(location)
			}
			maybeComment := ""
			if w.isKeyword(field.GetName()) {
				maybeComment = "# "
			}
			l("%s@property", maybeComment)
			if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
				typename := field.GetTypeName()
				if typename[0] == '.' && isASCIIUpper(typename[1]) {
					// Message defined in this file, relative path
					typename = typename[1:]
				}

				msg, ok := w.descriptors.Messages[typename]
				if ok && msg.Descriptor.Options.GetMapEntry() {
					// map generates a special Entry wrapper message.
					container := name("typing", "MutableMapping")

					keytype, valtype := w.keyAndValueTypes(msg.Descriptor, field)
					l("%sdef %s(self) -> %s[%s, %s]: ...",
						maybeComment,
						field.GetName(), container,
						keytype, valtype)
				} else {
					container := name(protoContainersPkg, "RepeatedCompositeFieldContainer")
					l("%sdef %s(self) -> %s[%s]: ...",
						maybeComment,
						field.GetName(),
						container, w.pythonType(field))
				}
			} else {
				l("%sdef %s(self) -> %s: ...",
					maybeComment,
					field.GetName(),
					w.pythonType(field))
			}
			l("")
		}

		// Write constructor type.
		if hasSelfField {
			l("def __init__(self_,")
		} else {
			l("def __init__(self,")
		}
		push()
		// write all the required arguments first so that python doesn't get
		// mad about non-default arguments after defaults
		for _, field := range desc.Field {
			if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REQUIRED {
				l("%s : %s,", field.GetName(), w.pythonType(field))
			}
		}
		// Non-required arguments need to be Optional so we can set a
		// default of None.
		optional := w.Name("typing", "Optional")
		// Force usage of key-value arguments (required by the upstream API).
		l("%s : %s[%s] = ...,", forceKeyValueArgsArg, optional, forceKeyValueArgsClass)
		for _, field := range desc.Field {
			if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REQUIRED {
				continue
			}

			maybeComment := ""
			if w.isKeyword(field.GetName()) {
				maybeComment = "# "
			}

			if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
				typename := field.GetTypeName()
				if len(typename) > 0 && typename[0] == '.' && isASCIIUpper(typename[1]) {
					// Message defined in this file, relative path
					typename = typename[1:]
				}

				msg, ok := w.descriptors.Messages[typename]
				if ok && msg.Descriptor.GetOptions().GetMapEntry() {
					// map generates a special Entry wrapper message.
					container := name("typing", "Mapping")

					keytype, valtype := w.keyAndValueTypes(msg.Descriptor, field)
					l("%s%s : %s[%s[%s, %s]] = ...,",
						maybeComment,
						field.GetName(),
						optional,
						container,
						keytype,
						valtype)
				} else {
					l("%s%s : %s[%s[%s]] = ...,",
						maybeComment,
						field.GetName(),
						optional,
						name("typing", "Iterable"),
						w.pythonType(field))
				}
			} else {
				// Optional fields are optional.
				l("%s%s : %s[%s] = ...,",
					maybeComment,
					field.GetName(),
					optional,
					w.pythonType(field))
			}
		}
		l(") -> None: ...")
		pop()
		pop()
		if desc.GetName() != clsName {
			l("")
			l("%s = %s", desc.GetName(), clsName)
		}
		if i < len(messages)-1 {
			l("")
		}
	}
}

func (w *pkgWriter) WriteExtensions(extensions []*descriptor.FieldDescriptorProto) {
	l := w.Line
	name := w.Name
	for _, extension := range extensions {
		l("%s: %s", extension.GetName(), name("google.protobuf.descriptor", "FieldDescriptor"))
	}
}

func (w *pkgWriter) WriteServices(services []*descriptor.ServiceDescriptorProto) {
	l := w.Line
	push := w.PushIndent
	pop := w.PopIndent
	name := w.Name

	if len(services) > 0 {
		l("class DescriptorProvider(%s):", name("typing", "Protocol"))
		push()
		l("def GetDescriptor(self) -> %s:", name("google.protobuf.descriptor", "ServiceDescriptor"))
		push()
		l("pass")
		pop()
		pop()
		l("")
	}
	for _, service := range services {
		l("%s_Stub: DescriptorProvider", service.GetName())
	}
}

func (w *pkgWriter) WriteFileDescriptor() {
	l := w.Line
	name := w.Name

	l("DESCRIPTOR: %s", name("google.protobuf.descriptor", "FileDescriptor"))
}

func (w *pkgWriter) keyAndValueTypes(msgDescriptor *descriptor.DescriptorProto, mapField *descriptor.FieldDescriptorProto) (interface{}, interface{}) {
	keytype := w.pythonType(msgDescriptor.Field[0])
	if proto.HasExtension(mapField.Options, mypy.E_Keytype) {
		keytype = w.pythonTypeHelper(mapField, mypy.E_Keytype)
	}

	valtype := w.pythonType(msgDescriptor.Field[1])
	if proto.HasExtension(mapField.Options, mypy.E_Valuetype) {
		valtype = w.pythonTypeHelper(mapField, mypy.E_Valuetype)
	}

	return keytype, valtype
}

func (w *pkgWriter) pythonType(fd *descriptor.FieldDescriptorProto) interface{} {
	return w.pythonTypeHelper(fd, mypy.E_Casttype)
}

func (w *pkgWriter) pythonTypeHelper(fd *descriptor.FieldDescriptorProto, ext *proto.ExtensionDesc) interface{} {
	if fd.Options != nil {
		casttype, err := proto.GetExtension(
			fd.Options,
			ext)

		if err == nil {
			split := strings.Split(*(casttype.(*string)), ".")
			pkg := strings.Replace(split[0], "/", ".", -1)
			return w.Name(pkg, split[1])
		} else if err != proto.ErrMissingExtension {
			panic(err)
		}
	}

	switch fd.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_DOUBLE, descriptor.FieldDescriptorProto_TYPE_FLOAT:
		return codegen.NewNestedImport(w.Name("builtins", ""), "float")
	case descriptor.FieldDescriptorProto_TYPE_INT64,
		descriptor.FieldDescriptorProto_TYPE_UINT64,
		descriptor.FieldDescriptorProto_TYPE_FIXED64,
		descriptor.FieldDescriptorProto_TYPE_SFIXED64,
		descriptor.FieldDescriptorProto_TYPE_SINT64,
		descriptor.FieldDescriptorProto_TYPE_INT32,
		descriptor.FieldDescriptorProto_TYPE_UINT32,
		descriptor.FieldDescriptorProto_TYPE_FIXED32,
		descriptor.FieldDescriptorProto_TYPE_SFIXED32,
		descriptor.FieldDescriptorProto_TYPE_SINT32:
		return codegen.NewNestedImport(w.Name("builtins", ""), "int")
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		return codegen.NewNestedImport(w.Name("builtins", ""), "bool")
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		return w.ImportMessage(fd)
	case descriptor.FieldDescriptorProto_TYPE_STRING:
		return w.Name("typing", "Text")
	case descriptor.FieldDescriptorProto_TYPE_BYTES:
		return codegen.NewNestedImport(w.Name("builtins", ""), "bytes")
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE,
		descriptor.FieldDescriptorProto_TYPE_GROUP:
		return w.ImportMessage(fd)
	default:
		panic("Unrecognized type: " + fd.Type.String())
	}
}

func (w *pkgWriter) ImportMessage(field *descriptor.FieldDescriptorProto) interface{} {
	name := field.GetTypeName()
	if name[0] == '.' && isASCIIUpper(name[1]) {
		// Message defined in this file, relative path
		return name[1:]
	}

	message, ok := w.descriptors.Messages[name]
	if !ok {
		panic("Unable to find proto " + name)
	}
	if message.File.GetName() == w.fd.GetName() {
		// Message defined in this package, absolute path
		split := strings.Split(field.GetTypeName(), ".")
		for i, segment := range split {
			if len(segment) > 0 && isASCIIUpper(segment[0]) {
				return strings.Join(split[i:], ".")
			}
		}
		panic("Could not parse absolute name for " + field.GetTypeName())
	}

	// Otherwise, the message is not defined in this package, so we need to import.
	split := strings.Split(field.GetTypeName(), ".")
	for i, segment := range split {
		if len(segment) > 0 && isASCIIUpper(segment[0]) {
			importName := w.Name(message.File.GetName(), segment)
			remains := strings.Join(split[i+1:], ".")
			if remains == "" {
				return importName
			}
			// Handle nested message/enum - we use importName for top level
			// in case import is aliased.
			return codegen.NewNestedImport(importName, remains)
		}
	}
	panic("Could not parse local name for " + name)
}

func getFieldNumber(msg descriptor.Message, field string) int32 {
	_, md := descriptor.ForMessage(msg)
	for _, f := range md.Field {
		if f.GetName() == field {
			return f.GetNumber()
		}
	}
	panic("DeveloperError: Field " + field + " not found in " + md.GetName())
}

func generateMypyStubs(
	req *plugin.CodeGeneratorRequest) *plugin.CodeGeneratorResponse {

	resp := &plugin.CodeGeneratorResponse{}

	descriptors, err := proto_codegen.ParseRequest(req)
	if err != nil {
		errMsg := err.Error()
		resp.Error = &errMsg
		return resp
	}

	files := []*plugin.CodeGeneratorResponse_File{}
	for _, fd := range descriptors.ToGenerate {
		comments := proto_codegen.NewCommentNode()
		for _, location := range fd.GetSourceCodeInfo().GetLocation() {
			comments.Add(location)
		}

		mypyStubs := newPkgWriter(fd, descriptors)
		mypyStubs.WriteHeader()
		mypyStubs.WritePublicImports(fd, req.ProtoFile)
		mypyStubs.WriteEnums(fd.EnumType, "", comments,
			getFieldNumber(fd, "enum_type"))
		mypyStubs.WriteMessages(fd.MessageType, "", comments,
			getFieldNumber(fd, "message_type"))
		mypyStubs.WriteExtensions(fd.Extension)

		mypyStubs.WriteFileDescriptor()

		if fd.Options.GetPyGenericServices() {
			mypyStubs.WriteServices(fd.Service)
		}

		pathName := strings.TrimSuffix(fd.GetName(), ".proto") + "_pb2.pyi"
		content := mypyStubs.String()
		files = append(files,
			&plugin.CodeGeneratorResponse_File{
				Name:    &pathName,
				Content: &content,
			})
	}

	resp.File = files
	return resp
}

func main() {
	req := command.Read()
	command.Write(generateMypyStubs(req))
}
